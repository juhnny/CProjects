#include <stdio.h>

void main()
{
	//사람마다 성적을 저장하는 경우. 계속 반복하긴 번거롭다.
	//int a, b, c;
	//a = 10;
	//b = 20;
	//c = 30; 
	//printf("%d \n", a);
	//printf("%d \n", b);
	//printf("%d \n", c);

	//배열 Array
	//같은 자료형의 변수 여러 개를 붙여서 한번에 만드는 문법
	//그냥 변수들의 모음. 사용하는 것도 똑같다. 특별하게 생각하지 말자. 
	int abc[3]; //세 칸 짜리 배열
	//배열의 이름: abc
	//배열의 index: 0, 1, 2,...
	//배열의 각 칸: 요소
	//배열의 칸 수: 크기 혹은 길이

	//sizeof를 쓰면 배열 전체의 바이트 수를 알려준다.
	printf("Type of abc : %d \n", sizeof(abc));
	//포인터 변수는 무조건 8바이트이지만 배열의 이름은 포인터 상수임에도 8바이트가 아니라 배열 전체의 크기를 알려준다.

	//int k = 3;
	//int bbb[k]; //C에서 배열의 길이는 상수만 입력 가능. 자바에선 변수도 가능
	
	//int vvv[]; //에러. 배열의 길이를 안 정하고 선언하면 에러. 그러나
	int vvv[] = { 10, 20, 30 }; //초기화를 같이 할 땐 생략 가능. 길이를 알 수 있으니까.

	//배열을 통으로 출력하거나 통으로 입력하는 문법은 없다. 칸칸 별로 제어한다.
	//메모리의 Stack에 생성되므로 기본값은 쓰레기값
	printf("%d \n", abc[0]);  
	printf("%d \n", abc[1]);
	printf("%d \n", abc[2]);
	
	abc[0] = 10;
	abc[1] = 20;
	abc[2] = 30;
	printf("\n %d %d %d \n\n", abc[0], abc[1], abc[2]);
	printf("%d \n", abc[0]);
	printf("%d \n", abc[1]);
	printf("%d \n", abc[2]);
	printf("%d \n", abc[3]); //정해진 칸을 초과해서 호출하면 같은 쓰레기값이 불려오는데...이건 뭘까. 메모리에 채워져 있는 패턴 110011001100을 끊어서 가져온 값.
	printf("%d \n", abc[4]); //인덱스가 길이보다 길어도 값이 나오는 이유는 인덱스 원리가 첫 주소부터 (자료형의 바이트수) * n 만큼 떨어진 곳의 주소를 가져오라는 말이기 때문.
	printf("%d \n", abc[5]); //

	//int a, b, c;를 연달아 선언해도 각각의 변수는 메모리의 랜덤한 위치에 생성된다.
	//배열의 각 항목들의 메모리상 위치는 연속해 있다. 
	//int abc[3];을 선언하면 4바이트(int) 짜리 3칸, 즉 12칸이 배정된다.  
	//첫번째 항목이 100~103번지에 위치하면 두번째 항목은 104~107번지, ... [n]번째 주소는 자료형이 int면 첫번째 주소 + 4n
	//포인터를 사용할 때 필요한 내용

	//배열의 초기화
	int arr[3] = { 11, 22, 33 }; //주의. 중괄호는 초기화의 문법일 뿐이지 배열이 중괄호 형태로 돼있는 건 아니다.

	int a = 1, b = 2, c = 3;
	int aaa[3] = {a, b, c}; //변수를 요소로 갖는 것도 물론 가능
	//int arr[3] = { 11, 22, 33, 44 }; //길이보다 많이 넣으면 에러
	char arr2[3] = { 'C', 'A' }; //길이보다 적게 넣는 건 가능. 나머지는 0으로 초기화.
	//char arr3[3] = {}; //이건 에러
	int arr4[3] = { 0 }; //활용법. 전부 0으로 초기화

	//배열의 대입?
	//arr = { 44, 55, 66 }; //에러. 배열을 통으로 대입하는 것은 불가. 통으로 입력하는 유일한 순간은 초기화 때 뿐.
	int brr[3];
	//brr = arr; //에러. 
	
	//대입은 하나씩만 가능
	brr[0] = arr[0];

	//배열 복사
	for (int i = 0; i < 3; i++) brr[i] = arr[i];

	//배열 거꾸로 복사
	for (int i = 0; i < 3; i++) brr[i] = arr[2 - i];

	//대칭 복사 ㅋㅋ
	int ccc[5] = { 1,2,3,4,5 };
	for (int i = 0; i < 5; i++)
	{
		ccc[4-i] = ccc[i];
	}
	for (int i = 0; i < 5; i++) printf("%d, ", ccc[i]);
	printf("Done \n\n");

	//예제. 시험 점수를 입력받아 모두 합하여 출력
	//int cnt = 0;
	//printf("시험 몇 과목?");
	//scanf_s("%d", &cnt);
	//int score[cnt] //아, 배열 길이에는 상수만 들어가지.. 변수 추가를 안 쓰곤 못하네

	//int score[3];
	//int total = 0;
	//for (int i = 0; i < 3; i++)
	//{
	//	printf("시험 점수는? ");
	//	scanf_s("%d", &score[i]);
	//	total += score[i];
	//}
	//printf("시험 총점은 %d점 \n", total);
	//printf("시험 평균은 %.2lf \n\n", (double)total / 3);

	//예제. 배열 중 최대값 구하기
	int eee[5] = { 13, 45, -4, 23, -66 };
	int max = eee[0];

	for (int i = 1; i < 5; i++)
	{
		if (max < eee[i]) max = eee[i];
	}
	printf("Max is %d \n\n", max);

	//& 주소연산자
	int x, y, z;
	printf("%x \n", &x);
	printf("%p \n", &x); //%p가 메모리 주소를 표현하는 형식지정자
	printf("%p \n", &y);
	printf("%p \n\n", &z);


	int xxx[3];
	printf("%p \n", &xxx[0]);
	printf("%p \n", &xxx[1]);
	printf("%p \n", &xxx[2]);
	printf("%p \n", &xxx[3]);
	printf("%p \n", &xxx[4]);
	printf("%p \n", xxx); //배열의 이름은 배열 첫 요소의 주소와 같다. xxx == &xxx[0]

	//출력해보면 변수 주소의 규칙성을 볼 수 있다. 
	//메모리는 뒤쪽부터 채워진다. 자료가 끊어지는 걸 막기 위해.
	//int 변수들 사이의 간격도 32바이트. 물론 바뀔 수 있다. 메모리 효율성을 위한 연구 결과.
	//

	int w = 10;
	printf("%p \n\n", &w);

	//xxx[n]의 값을 잘 조절해보면 w의 값을 찾을 수도 있다. 값을 대입할 수도 있고.

	//문자열은 각 요소가 char인 배열이다.

	

	//변수의 연산 원리
	int m = (int)2.5;
	printf("%d\n", m);

	printf("%lf \n", (double)5/2);

	double result = 5 / 2;
	printf("%lf \n", result);
	//double에 넣었는데 왜 2.5가 아니라 2.0이 나오느냐. 
	//연산을 위해 피연산자들을 메모리에 저장.
	//5와 2는 정수이므로 정수형 기본값인 int로 임의의 메모리 위치에 저장
	//double인 result는 8비트 할당
	//
	//나눗셈 연산이 대입연산보다 먼저겠지.
	//컴퓨터는 연산을 할 때 자료형이 같은? 바이트 자릿수가 같아야만? 연산 가능
	//5와 2를 cpu의 레지스터 R0과 R1으로 불러가서 연산 후 ACC에 보관
	//= 연산은 오른쪽의 '메모리값'을 왼쪽의 메모리 주소로 대입한다.
	//ACC를 바로 변수 안에 넣는 게 아니라 메모리에 임시 저장하고 그걸 다시 변수에 대입한다는 것
	//이 임시 메모리 공간을 몇 바이트로 할 것이냐? 피연산자들을 보고 판단
	//피연산자가 int와 int면 int로 만들고 int와 double이면 double로 만들고 long과 float이면 float으로 만든다. 
	//long과 float은 똑같은 4바이트인데? 저장방식(고정소수점과 부동소수점)이 달라서 float의 정보량이 더 '크기' 때문. '정보량이 더 큰' 자료형에 맞춘다. 정보 소실 막기 위해
	//임시 4바이트 공간에 2.5를 저장하려다보니 2밖에 저장이 되지 않는 것.
	// 
	//이걸 다시 double인 변수에 넣으려면 8바이트 메모리를 임시 할당해 2를 double 형태로 바꿔주고
	//이 메모리값을 드디어 변수 result에 대입한다.

	//CPU의 모든 연산이 연산자들이 메모리에 올라와있을 것을 요구하나?
	
}