#include <stdio.h>

//int g = 10;
//
//void main()
//{
//	printf("g1 : %d \n", g);
//
//	int g = 5; //전역변수와 같은 이름의 지역변수를 만들 수 있다.
//	printf("g2 : %d \n", g); //하지만 호출하면 같은 이름의 지역변수가 먼저다.
//	
//	//C에서 함수 안에 함수를 다시 만들 순 없다. 되는 언어도 있지만..
//	//void aaa()
//	//{ }
//	
//	if (1)
//	{
//		int g = 1; //중괄호 안은 또 다른 지역이므로 같은 이름의 지역변수를 또 만들 수 있다. 하지만 선호되진 않는다. 해석에 혼동이 오니까.
//		printf("g3 : %d \n", g);
//	}
//
//	if (1)
//	{
//		printf("g4 : %d \n", g);
//	}
//}

//정적변수

//사용자가 이 기능을 쓸 때마다 몇 번째 사용자인지 기록하는 함수


void aaa()
{
	//int cnt = 0; //count를 지역변수로 만들면 함수 호출이 끝날 때마다 초기화될 것이다.
	//			 //그렇다고 전역변수로 만들면 다른 함수에서 실수로 불려와서 수정될 수도 있고
	//			 //다른 개발자들이 보기에 전역변수니까 프로그램 전반에 쓰이겠구나 오해할 수도 있고
	//			 //cnt라는 변수명을 함수마다 다른 이름으로 만들어줘야 하는 게 문제. cnt1, cnt2, cnt3...
	static int cnt = 0; //그럴 때 쓰는 게 정적변수
				 //정적변수가 선언된 함수가 호출된 적이 없어도 프로그램이 시작하면 바로 전역변수와 함께 만들어진다.
				 //함수 안에 쓰여있어도 함수를 처음 불러올 때만 변수가 생성되고 다음부터는 이 명령이 읽혀도 무시된다. 매번 0이 되는 게 아니다!
				 //메모리의 Data 영역에 생성되므로 선언만 해도 0이지만 개발자들의 선호로 인해 = 0 까지 붙여주기도.
	
	cnt++;
	printf("%d 번째 사용자입니다.", cnt);
}

//외부변수 external variable
//다른 파일에서 선언된 전역변수

//레지스터 변수
//메모리가 아니라 CPU에 생성된 변수. 장점은 '빠르다'
//CPU 안에 생성할 공간이 없을 땐 메모리로 넘어가서 생성된다.
//그럼 일단 cpu 안에 생성하고 보면 되는거 아닌가 할 수 있지만 이 변수를 cpu에 넣을 지 메모리에 넣을지 계산하는 것도 시간이 걸려서 굳이...
//실무에서 쓸 일은 거의 없다.


//재귀함수
//기본형
//언뜻 무한반복처럼 보이나 aa라는 함수의 메모리 영역을 새롭게 계속 생성하기 때문에 OS에서 혹은 IDE에서 경고를 한다.

//void aa()
//{
//	printf("aaa \n");
//	aa();
//}
//
//void main()
//{
//	aa();
//}

//활용방법

void bb(int n)
{
	if (n <= 0) return;
	printf("bb \n");
	bb(n - 1);
}

void main()
{
	bb(5);
}